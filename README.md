# 키친포스
레거시 코드 리팩토링 연습
- 객체, 패키지 의존 관계 고민
- 테스트 코드 작성
- JDBC -> JPA 마이그레이션

## step1
1. Service는 Mockito를 사용한 슬라이스 테스트를 진행하였습니다.
2. 모킹없이도 짜보고 싶어서 MenuServiceTest는 모킹을 제거하고 통합테스트를 진행해보았습니다.
3. SpringBoot 2.4부터 properties file에 여러 프로파일을 등록할 수 있다는 소식을 들어 학습 후 적용해보았습니다. [정리](https://ecsimsw.tistory.com/entry/Multi-document-Properties-Files-with-Spring-Boot-24)
4. 테스트 테이블 초기화를 위해 flyway 마이그레이션 스크립트 "/db/test/R__Initialize_tables.sql"를, 테스트 격리를 위해 "/db/test/truncate.sql"를 사용하고 있습니다.

## step2

Step2에선 아래 4가지를 해봤습니다.

1. JPA 적용
2. 연관 관계 매핑
3. 테스트 코드 리팩토링
4. 서비스 코드 리팩토링

사실 이전까지 JPA 사용시 연관관계 매핑을 그저 공식처럼만 적용해서 이번 기회에 일부러라도 평소에 안하던 매핑도 해보고, 일부러 쿼리 나가는 것 시험해보는 시간을 가졌습니다.

재밌었던게 저는 개인적으로 OneToMany 단방향은 절대 안돼 주의였는데, 일과 다, 객체를 다루는 관계에 따라서 성능을 생각한 양방향보다 차라리 OneToMany 단방향이 더 깔끔하겠다는 생각도 드네요. 물론 ManyToOne 단방향이 깔끔하면 그게 베스트라고 생각하지만, 로직상 OneToMany 관계를 유지하고 싶은데 성능을 위해 무조건적으로 양방향을 뚫는게 정답은 아니구나라는 생각을 처음해본 것 같아요.

단적으로 예를 들면 한번 저장되면 관계내에서 추가, 삭제가 없는 Order와 OrderLineItem은 추가 쿼리 걱정을 조금은 덜해도 되지 않을까, 그러니까 쿼리 성능 개선이라는 생각으로 양방향을 뚫는게 큰 개선이 없진 않을까 하는 생각부터, Order에 OrderLineItem이 추가되어야한다면 그건 그냥 잘못된 Order니 주문 자체를 취소하고 새로운 Order를 만들어 영속하는게 맞는 것 같다는 생각도 드네요.

정말 재밌네요. 저한테는 되게 의미있었던 스텝이었어요. Step3에선 분리를 고민해볼 생각이에요.
더 공부해서 블로그 같은 곳에 다시 정리해야겠어요. 크크

아 그리고 테스트하던 부분들이 여기 저기 남아있어요. 쿼리 확인을 위한 Application 파일안의 TestData 클래스나 applicationProperties, AssertJ 테스트하던 MenuServiceTest. Step3에서 좀만 더 가지고 놀다가 지울게요. 😅


## step3

step3에선 이런 변화가 있었어요!

1. 패키지 분리
2. 연관 관계 분리 (관계 끊기)
3. 유효성 검증 객체 분리
4. 테스트 코드 리팩토링 (AssertJ)

이번에는 패키지 분리랑 연관 관계 분리를 도전했어요. 사실 Menu - MenuProduct / Order - OrderLineItem을 제외하곤 그냥 다 관계를 끊고 id로 다룬거 같아요. 기준은 함께 생성되고 함께 제거되나!! 제 기준에 공감이 되실지 모르겠네요.

특히 재밌었던 부분이 서비스 코드 테스트 안에서 어떻게 하면 관계를 끊을 수 있을까 고민했던 부분이 재밌었어요. 이전 step2의 구조처럼 연관 관계가 이어졌을 때는 한 객체를 만들기 위한 연관된 객체를 생성하는 로직이 필요했는데, 나중에 프로젝트가 커지고 관계가 많아지면 그 과정이 엄청나게 복잡하고 많아질 것 같았거든요. 그래서 생각한 방식이 id로 연관 관계를 끊고, Mocking 이용, 연관 관계를 분리하고 repository를 mocking해서 서비스 코드 안에서는 마치 데이터가 있는 척하는 방식으로 테스트 코드를 바꿔봤어요. 

문제는 이렇게 mocking으로 진행할 경우 SpringBootTest의 컨테이너 캐싱이 제대로 적용되지 않는다는 자료를 봐서 어떻게 해야 좋을지 더 공부해올 생각이에요. [자료](https://suhwan.dev/2019/03/27/spring-test-context-management-and-caching/)

다음 단계에서는 패키지 별 모듈 분리와 테스트 코드 성능 개선을 작업해볼 생각이에요.
잘부탁드립니다. 화이팅이에요!!!

## 요구 사항

#### MenuGroup
- 메뉴 그룹을 생성한다.
- 메뉴 그룹 목록을 반환한다.

#### Menu
- 메뉴를 생성한다.
   - 메뉴에는 이름, 가격, 메뉴 그룹, 메뉴 상품 리스트가 포함된다. 
   - 메뉴 그룹이 존재해야 한다.
   - 메뉴의 가격은 메뉴 상품의 가격 합보다 클 수 없다.
- 메뉴 목록을 반환한다.

#### Order
- 주문한다.
    - 주문 테이블, 주문 상태, 주문 시간, 주문 항목 리스트가 포함된다.
    - 주문 항목이 1개 이상이어야 한다.
    - 주문 항목의 메뉴가 존재해야 한다.
    - 빈 테이블이 아니어야한다.
- 주문 목록을 반환한다.
- 주문 상태를 수정한다.
    - 존재하는 주문이어야 한다.
    - 현재 완료 상태의 주문이 아니어야한다.
    - 주문 상태는 COOKING, MEAL, COMPLETION 중 하나여야 한다.

#### Product
- 상품을 생성한다.
    - 상품 가격은 양수여야한다.
- 상품 목록을 반환한다.

#### Table Group
- 단체 지정을 생성한다.
    - 단체 지정 테이블의 개수는 2개 이상이다.
    - 비어있지 않은 테이블만 단체로 묶을 수 있다.
    - 이미 단체가 존재하는 테이블은 단체로 묶을 수 없다.
- 단체 지정을 해제한다.
    - COOKING, MEAL 상태의 테이블 그룹은 해제할 수 없다.

#### Table
- 테이블을 생성한다.
    - 단체 정보, 손님 수, 빈 테이블 여부가 포함된다.
- 테이블 리스트를 반환한다.
- 테이블 상태를 빈 테이블로 표시한다.
    - 존재하는 테이블이어야한다.
    - 단체 지정이 되어있지 않아야한다.
    - COOKING, MEAL 상태의 테이블은 빈 테이블로 표시할 수 없다.
- 손님 수를 수정한다.
    - 손님 수는 음수일 수 없다.
    - 존재하는 테이블이어야한다.

## 용어 사전

| 한글명 | 영문명 | 설명 |
| --- | --- | --- |
| 상품 | product | 메뉴를 관리하는 기준이 되는 데이터 |
| 메뉴 그룹 | menu group | 메뉴 묶음, 분류 |
| 메뉴 | menu | 메뉴 그룹에 속하는 실제 주문 가능 단위 |
| 메뉴 상품 | menu product | 메뉴에 속하는 수량이 있는 상품 |
| 금액 | amount | 가격 * 수량 |
| 주문 테이블 | order table | 매장에서 주문이 발생하는 영역 |
| 빈 테이블 | empty table | 주문을 등록할 수 없는 주문 테이블 |
| 주문 | order | 매장에서 발생하는 주문 |
| 주문 상태 | order status | 주문은 조리 ➜ 식사 ➜ 계산 완료 순서로 진행된다. |
| 방문한 손님 수 | number of guests | 필수 사항은 아니며 주문은 0명으로 등록할 수 있다. |
| 단체 지정 | table group | 통합 계산을 위해 개별 주문 테이블을 그룹화하는 기능 |
| 주문 항목 | order line item | 주문에 속하는 수량이 있는 메뉴 |
| 매장 식사 | eat in | 포장하지 않고 매장에서 식사하는 것 |
